{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the Chalmers Qubit simulator package! A simulation framework for Chalmers devices that can be used to simulate the running of quantum algorithms with realistic noise. We follow qutip-qip to build a processor that can take in a quantum circuit (e.g., a QASM cicruit) and performs a master equation simulation adding noise such as T1 and T2. It is also possible to perform a Monte-Carlo trajectory simulation and customize the processor to add various types of noise such as ZZCrossTalk.</p> <p>The package is under development and testing. </p>"},{"location":"#installation","title":"Installation","text":"<p>The main requirement to use this package is qutip-qip based on qutip: The Quantum Toolbox in Python. The requirements are already specified in the <code>setup.py</code> file and you can install the package <code>chalmers_qubit</code> simply by downloading this folder or cloning this repository and running:</p> <pre><code>pip install .\n</code></pre> <p>to get the minimal installation. You can instead use <code>'.[full]'</code> to install the package with all optional dependencies, such as matplotlib. Moreover, it might be beneficial to install an editable version. In the editable version, changes to the code are reflected system-wide without requiring a reinstallation.</p> <pre><code>pip install -e '.[full]'\n</code></pre> <p>If you do not care about making changes to the source code and just want to try out the package (e.g., from Google Colab), you can do a git+ install with</p> <pre><code>pip install git+https://github.com/aqp-mc2-chalmers/chalmers-qubit.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The usage of the package follows qutip-qip where first, a quantum circuit is defined using <code>qutip-qip</code> and then run on one of the custom Chalmers processors, e.g., the processor called sarimner. The custom processor is defined in <code>chalmers_qubit.sarimner.processor</code> and can be initialized with a <code>model</code>, <code>compiler</code> and <code>noise</code>. </p> <p>Note that only gates with compilation instructions in <code>chalmers_qubit/sarimner/compiler.py</code> will work for this particular processor.</p> <p>Notebooks exploring the usage of the simulator is available in <code>examples/</code>. </p> <pre><code>import numpy as np\nfrom qutip import basis, tensor\nfrom qutip_qip.circuit import QubitCircuit\nfrom chalmers_qubit.sarimner import (\n    SarimnerProcessor,\n    SarimnerModel,\n    SarimnerCompiler,\n    DecoherenceNoise,\n    ZZCrossTalk,\n)\n\n# Define a circuit\nqc = QubitCircuit(2)\nqc.add_gate(\"RX\", targets=0, arg_value=np.pi / 2)\nqc.add_gate(\"RY\", targets=1, arg_value=np.pi / 2)\nqc.add_gate(\"CZ\", controls=0, targets=1)\n\n# Define a Model with model parameters\n# All frequencies are defined in GHz, and times in ns.\nmodel = SarimnerModel(\n    qubit_frequencies=[2 * np.pi * 5.0, 2 * np.pi * 5.4],\n    anharmonicities=[-2 * np.pi * 0.3, -2 * np.pi * 0.3],\n    coupling_matrix=np.array([[0, 1e-4], [0, 0]]),\n)\n\n# Load a compiler\ncompiler = SarimnerCompiler(model=model)\n\n# Define all the noise objects as a list.\nnoise = [\n    DecoherenceNoise(t1=[60 * 1e3, 70 * 1e3], t2=[100 * 1e3, 120 * 1e3]),\n    ZZCrossTalk(cross_talk_matrix=np.array([[0, 1e-4], [0, 0]])),\n]\n\n# Initialize the processor\nprocessor = SarimnerProcessor(model=model, compiler=compiler, noise=noise)\n\n# Load the circuit that generates the pulses to run the simulation\ntlist, coeffs = processor.load_circuit(qc)\n\n# Initial state for the simulation.\n# The default assumptions is that each transmon is a qudit with 3 levels.\ninit_state = tensor(basis(3, 1), basis(3, 1))\n\n# Run master equation simulation\nresult = processor.run_state(init_state)\nprint(\"Final state\", result.states[-1])\n\n# Run the same circuit but with mcsolve using 100 trajectories.\nresult = processor.run_state(init_state, solver=\"mcsolve\", ntraj=100)\nprint(\"Final state\", result.states[-1])\n</code></pre> <p>It is also possible to import QASM circuits.</p>"},{"location":"#development","title":"Development","text":"<p>In order to add new custom pulses or modify the device, edit the processor, or compiler the tutorials and detailed instructions in qutip-qip.</p> <p>The tutorials show examples of how to customize the processor. If you have installed the package in the develop mode, any changes to the processor, e.g., adding a new gate will be reflected immediately system-wide without requiring a reinstallation of the package.</p>"},{"location":"#support","title":"Support","text":"<p>This package was built from contributions by Pontus Vikst\u00e5l, Kamanasish Debnath and Shahnawaz Ahmed.</p> <p>Contact vikstal@chalmers.se, shahnawaz.ahmed95@gmail.com or anton.frisk.kockum@chalmers.se for help and support.</p>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#single-qubit-gates","title":"Single-qubit gates","text":"<p>On this page we are describing how a single-qubit gate that implements rotation around the x- or y-axis on the Bloch sphere can be performed.</p> <p>We consider a driven weakly anharmonic qubit whose Hamiltonian in lab frame can be written as</p> \\[\\begin{equation}     \\label{eq:Transmon}     \\frac{H}{\\hbar} = \\omega_q a^\\dagger a+\\frac{\\alpha}{2} a^\\dagger a^\\dagger a a +\\mathcal{E}(t)a^\\dagger+\\mathcal{E}(t)^*a, \\end{equation}\\] <p>where \\(\\omega_q\\equiv \\omega_q^{0\\rightarrow 1}\\) is the qubit frequency and \\(\\alpha = \\omega_q ^{1\\rightarrow 2}-\\omega_q^{0\\rightarrow 1}\\) is the anharmonicity. The driving and control is given by</p> \\[\\begin{equation}     E(t)= \\begin{cases}          \\Omega^x(t)\\cos(\\omega_d t)+\\Omega^y(t)\\sin(\\omega_d t),&amp; 0&lt;t&lt;t_g, \\\\ 0, &amp; \\text{otherwise}.     \\end{cases} \\end{equation}\\] <p>Here \\(\\Omega^x(t)\\) and \\(\\Omega^y(t)\\) are two independent quadrature controls, \\(t_g\\) is the total gate-time, and \\(\\omega_d\\) is the drive frequency. Next we move into the rotating frame of the drive by performing the following unitary transformation \\(U(t)=e^{i\\omega_r t a^\\dagger a}\\), where \\(\\omega_r\\) is the rotating frame frequency. The Hamiltonian in the rotating frame after having performed the rotating wave approximation reads</p> \\[\\begin{multline}     \\frac{H^R}{\\hbar}=     \\Delta a^\\dagger a + \\frac{\\alpha}{2} a^{\\dagger 2}a^2 +      (\\frac{\\Omega^x(t)}{2}\\cos([\\omega_r-\\omega_d]t)-\\frac{\\Omega^y(t)}{2}\\sin([\\omega_r-\\omega_d]t))(a^\\dagger + a) \\\\     + (\\frac{\\Omega^x(t)}{2}\\sin([\\omega_r-\\omega_d]t)+\\frac{\\Omega^y(t)}{2}\\cos([\\omega_r-\\omega_d]t))(ia^\\dagger - ia), \\end{multline}\\] <p>where \\(\\Delta \\equiv \\omega_q - \\omega_r\\) is the qubit detuning. </p> <p>As a concrete example, assume that we apply a pulse at the qubit frequency \\(\\omega_d=\\omega_q\\), and choose the rotating frame of the drive \\(\\omega_r=\\omega_d\\). Then,</p> \\[\\begin{equation}     \\frac{H^R}{\\hbar} =     \\frac{\\alpha}{2} a^{\\dagger 2}a^2     + \\frac{\\Omega^x(t)}{2}(a^\\dagger + a)     + \\frac{\\Omega^y(t)}{2}(ia^\\dagger - ia). \\end{equation}\\] <p>If we treat the Hamiltonian as an effective two level system (ignoring the anharmonic term) and make the replacement \\((a^\\dagger + a)\\rightarrow \\sigma_x\\) and \\((ia^\\dagger-ia)\\rightarrow \\sigma_y\\), we obtain</p> \\[\\begin{equation}     \\frac{H^R}{\\hbar} = \\frac{\\Omega^x(t)}{2}\\sigma_x + \\frac{\\Omega^y(t)}{2}\\sigma_y, \\end{equation}\\] <p>showing that an in-phase pulse (i.e. the \\(\\Omega^x(t)\\) quadrature component) corresponds to a rotation around the \\(x\\)-axis while the out-of-phase pulse (i.e. the \\(\\Omega^y(t)\\) quadrature component), corresponds to rotations about the \\(y\\)-axis. As a concrete example of an in-phase pulse, writing out the unitary evolution operator yields,</p> \\[\\begin{equation}     U^R(t)=\\exp([-\\frac{i}{2}\\int_0^t\\Omega^x(t')\\mathrm{d}t']\\sigma_x). \\end{equation}\\] <p>By defining the angle</p> \\[\\begin{equation}     \\Theta(t)=\\int_0^t\\Omega^x(t')\\mathrm{d}t', \\end{equation}\\] <p>which is the angle a state is rotated given a waveform envelope \\(\\Omega^x(t)\\). This means that to implement a \\(\\pi\\)-pulse on the \\(x\\)-axis one would solve \\(\\Theta(t)=\\pi\\) and output the signal in-phase with the qubit drive.</p> <p>In this simple example we assumed that we could ignore the higher levels of the qubit. In general leakage errors which take the qubit out of the computational subspace as well as phase errors can occur. To combat theses errors the so-called DRAG<sup>1</sup> procedure (Derivative Reduction by Adiabatic Gate) is used. In doing so we apply an extra signal in the out-of-phase component, such that</p> \\[\\begin{align}     \\Omega^x(t) = B e^{-\\frac{(t-t_g)^2}{2\\sigma^2}},\\quad     \\Omega^y(t) = q\\sigma\\frac{d\\Omega^x(t)}{dt} \\end{align}\\] <p>where \\(q\\) is a scale parameter that needs to be optimized with respect to a \\(\\pi/2\\)-pulse. Interchanging \\(\\Omega^x(t)\\) and \\(\\Omega^y(t)\\) in the equation above corresponds to DRAG pulsing the \\(\\Omega^y(t)\\) component. The amplitude \\(B\\) is fixed such that</p> \\[\\begin{equation}     \\Big|\\int_{0}^{t}[\\Omega^x(t')+i\\Omega^y(t')]\\mathrm{d}t'\\Big|=\\pi. \\end{equation}\\] <p>for a \\(\\pi\\)-pulse with DRAG.</p> <ol> <li> <p>F. Motzoi, J. M. Gambetta, P. Rebentrost, and F. K. Wilhelm. Simple pulses for elimination of leakage in weakly nonlinear qubits. Phys. Rev. Lett., 103:110501, Sep 2009. doi:10.1103/PhysRevLett.103.110501.\u00a0\u21a9</p> </li> </ol>"}]}